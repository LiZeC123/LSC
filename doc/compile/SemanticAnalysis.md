
语义分析
-------------


### 变量管理
变量管理主要负责的是在编译过程中的变量创建,存入符号表,从符号表中取出合适的变量等. 以下依次分析这几种情况

#### 1. 创建变量
变量对象有三种来源方式
1. 源程序中显式的定义
	- 源程序显式指明ID
	- 需要分析是否是全局变量,是否extern引导,是否参数变量等
2. 源程序中的常量
	- 需要编译器指定一个内部的ID
	- 需要分析的属性相对较少,可以视为一个特殊的变量
3. 表达式中的中间变量
	- 需要编译器指定一个内部ID

#### 2. 作用域分析
可以创建一个类,给每个作用域分配一个唯一的序号,并且保存当前作用域路径上的作用域序号,例如

``` C
int b = 2;              // 作用域1 路径 /1
int main(){
	int a = 3;          // 作用域2 路径 /1/2
	while(a < 4){
		a++;            // 作用域3 路径 /1/2/3
	}

	while(a< 8){
		a++;            // 作用域4 路径 /1/2/4
	}
	b++;                // 作用域2 路径 /1/2
}
```
之后使用一个链表结构来保存这个路径信息,即可完全的保存一个变量的作用域信息,从而为之后的变量存放,查询奠定基础

#### 3. 变量存放
存放变量的数据结构是hash表,通过变量名就可以直接定位变量的位置,由于可以在不同的作用域下定义同名变量,因此hash表的每个节点实际上是一个链表,用C++表示,相当于是
```
	map<string,vector<Var>>
```
通过名字定位到变量的链表以后,还需要在链表中查询是否存在同名的变量,如果存在,说明变量已经被定义,需要给出语义错误. 对于同名变量的判断实际上只需要比较各个变量的路径的最后一个数字是否相同即可.

为了便于操作,实际的编译器中,变量表被定义为
```
	map<string,vector<Var*>*>
```
本质来说,与之前的操作相比没有太多区别,仅仅是多了一些指针的操作.

#### 4. 变量获取
变量获取与存放类似,主要是作用域的处理,而且由于内层作用域可以直接访问外层作用域的变量,因此查询的时候,并不是变量路径与当前路径完全匹配,才是需要的变量. 变量路径是当前路径任意前缀的变量都有可能. 而且,由于内层变量覆盖外层变量,因此,在所有前缀满足的变量中,前缀长度最长的变量(至多与当前路径一样长)就是最后获得的变量.

### 函数管理
函数管理主要负责的是在编译过程中的函数创建,添加和获取,以下依次分析这几种情况

#### 1. 函数创建
在递归下降分析的过程中,实际上在`<idtail>`部分就可以获得函数返回类型,函数名,参数列表. 这些要素已经可以完全的确定一个函数. 之后在`<funtail>`部分,就可以进一步的确定是函数声明还是函数定义,从而选择合适的方式插入到函数表中.

插入函数表有两种方式
1. 插入函数声明
2. 插入函数定义

两组仅在函数的某些属性上有所区别,其余特性完全一致
