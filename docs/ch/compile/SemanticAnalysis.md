
语义分析
-------------


### 变量管理
变量管理主要负责的是在编译过程中的变量创建,存入符号表,从符号表中取出合适的变量等. 以下依次分析这几种情况

#### 1. 创建变量
变量对象有三种来源方式
1. 源程序中显式的定义
	- 源程序显式指明ID
	- 需要分析是否是全局变量,是否extern引导,是否参数变量等
2. 源程序中的常量
	- 需要编译器指定一个内部的ID
	- 需要分析的属性相对较少,可以视为一个特殊的变量
3. 表达式中的中间变量
	- 需要编译器指定一个内部ID

#### 2. 作用域分析
可以创建一个类,给每个作用域分配一个唯一的序号,并且保存当前作用域路径上的作用域序号,例如

``` C
int b = 2;              // 作用域1 路径 /1
int main(){
	int a = 3;          // 作用域2 路径 /1/2
	while(a < 4){
		a++;            // 作用域3 路径 /1/2/3
	}

	while(a< 8){
		a++;            // 作用域4 路径 /1/2/4
	}
	b++;                // 作用域2 路径 /1/2
}
```
之后使用一个链表结构来保存这个路径信息,即可完全的保存一个变量的作用域信息,从而为之后的变量存放,查询奠定基础

#### 3. 变量存入
存放变量的数据结构是hash表,通过变量名就可以直接定位变量的位置,由于可以在不同的作用域下定义同名变量,因此hash表的每个节点实际上是一个链表,用C++表示,相当于是
```
	map<string,vector<Var>>
```
通过名字定位到变量的链表以后,还需要在链表中查询是否存在变量,如果存在,说明变量已经被定义,此时还需要查询已经定义过的变量和当前变量是否在同一作用域. 对于同名变量的判断实际上只需要比较各个变量的路径的最后一个数字是否相同即可. 如果是同样作用域则需要给出语义错误. 

为了便于操作,实际的编译器中,变量表被定义为
```
	map<string,vector<Var*>*>
```
本质来说,与之前的操作相比没有太多区别,仅仅是多了一些指针的操作.

#### 4. 变量取出
变量获取与存放类似,主要是作用域的处理,而且由于内层作用域可以直接访问外层作用域的变量,因此查询的时候,并不是变量路径与当前路径完全匹配,才是需要的变量. 变量路径是当前路径任意前缀的变量都有可能. 而且,由于内层变量覆盖外层变量,因此,在所有前缀满足的变量中,前缀长度最长的变量(至多与当前路径一样长)就是最后获得的变量.

---------------------------------------------------------------------------------

### 函数管理
函数管理主要负责的是在编译过程中的函数创建,添加和获取,以下依次分析这几种情况

#### 1. 函数创建
在递归下降分析的过程中,实际上在`<idtail>`部分就可以获得函数返回类型,函数名,参数列表. 这些要素已经可以完全的确定一个函数. 之后在`<funtail>`部分,就可以进一步的确定是函数声明还是函数定义,从而选择合适的方式插入到函数表中.

插入函数表有两种方式
1. 插入函数声明
2. 插入函数定义

两组仅在函数的某些属性上有所区别,其余特性完全一致

#### 2. 函数存入
由于函数可以进行声明,因此同一个函数可能会被多次存入. 因此在存入之前需要进行若干判断,包括
1. 检查当前函数是否是extern引导
2. 之前是否存在此函数
	1. 如果已经存在且为函数声明,若声明与当前定义一直,则使用新的函数定义覆盖原有的声明,否则报告函数声明错误
	2. 如果已经存在且为函数定义,则报告函数重定义错误
	3. 如果不存在,则可以直接存入

由于当前的语言不支持函数重载,因此对于函数是否相同的判断仅仅是判断函数名是否相同.

#### 3. 函数取出
取出函数时,需要提供函数名和参数列表. 由于当前语言不支持重载,因此实际上只需要函数名即可完成函数的取出,但同时提供参数列表有两个好处
1. 提供函数参数列表检查,如果提供的参数列表类型与之前存入的不一致,则可以提供错误报告
2. 为后续实现函数重载预留接口

只要使用与变量表相同的结构,就可以轻松的实现同名函数的存取,因此现在就要求提供参数列表可以为后续的重载实现提供便利.


---------------------------------------------------------------------------------

### 语义分析
实际上,从递归下降开始,后面的语义分析,符号表管理,中间代码生成等操作都是同步进行的, 这种模式也叫语法制导翻译. Lsc语言的语义分析操作主要包括以下几个方面.

#### 1. 声明和定义检查
对于变量和函数的检查,在前面的变量管理和函数管理中以及有所提及,包括变量未定义,变量重定义,函数未定义,函数重定义,函数定义不匹配等.

此外还包括在语法分析中提及的不能定义void变量检查,左值与右值检查,数组长度必须为正数等

#### 2. 表达式检查
表达式检查主要包括在表达式中的各种变量形式与运算法之间能否运算之间的问题,由于Lsc语言做了一些简化操作,因此相比于C语言,此部分有较多限制,具体可以查阅[compile/GenIR.cpp](../../compile/GenIR.cpp) 文件

#### 3. 语句检查
语句检查主要包括函数声明的参数与返回值类型与实际参数和返回值类型是否匹配,break与continue语句出现位置是否合法等.

#### 4. 列表
合并上述提及的所有错误类型即可得到最后的错误列表,完整的列表可见[compile/common.h](../../compile/common.h)