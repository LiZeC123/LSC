中间代码转X86汇编
===================

基本原则
---------
根据四元式的结构特点,同时为了避免寄存器分配的繁琐性,因此每条中间代码都翻译成三个步骤,即

1. 取操作数
2. 执行指令
3. 写回结果

按照以上三个步骤执行,则在任意中间执行执行完毕后,寄存器中都不保存数据,后续的指令可以任意的使用任意寄存器.

取操作数的翻译
-------------
对于操作数,都默认将操作数读取到eax或ecx,同时对于不同的数据形式有如下的几种情况
1. 全部符号,直接使用符号名,例如`mov eax, [name]`,后续汇编器会将全局符号名直接转换为内存地址
2. 局部符号,使用`ebp+偏移`的方式进行访问,例如`mov eax, [ebp+12]`,局部符号偏移值在编译过程中已经被确定,可以直接使用
3. 常量,使用立即数方式访问,例如`mov eax,12`,常量的值在编译过程中已经被确定,也可以直接使用

写回结果的翻译
-------------
对于任意结果变量,有如下的几种情况
1. 全局符号,直接使用符号名,例如`mov [name], eax`,同样,在后续的汇编阶段,全局符号名会直接转化为内存地址
2. 局部变量,还是使用`ebp+偏移`的方式进行访问,与读取完全一致,不再赘述


局部变量初始化翻译
----------------
对于已经初始化的局部变量,在执行中间代码`OP_DEC`时执行初始化操作,根据变量的类型向相应的寄存器写入常量值即可.


取地址操作的翻译
-----------------
对于任意变量,获得其地址有两种情况
1. 全局符号,直接将变量名移动到寄存器即可,例如`mov eax, name`
2. 局部符号,使用lea指令获得地址,例如`lea eax, [ebp-12]`

